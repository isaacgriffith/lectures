Kevin and Jon have made the argument since we shifted computer science (and INFO) that INFO student's don't need to CS 2235. Specifically, they don't need to know how to build linked lists, trees, etc.

- As I said back then, that I can agree that they don't need to know how to "build" such data structures, but I would argue that any informaticist (software, it, health informatics) should no something about the different types of data structures and how and why we use them in practice. Given that a significant focus of INFO is on the transfer, transformation, and storage of date across and in various mediums. Understanding which data structures to use and why we use them seems to be a core concept to this work.

- I would also argue that these students should know something about logic and set theory (not enough to construct proofs) as these are foundational to understanding the construction and implementation of business rules as part of the business logic layer. Additionally, this would seem as a great basic understanding to have when attempting to develop data filters, security policies, etc rather than fumbling around and trying random things until it just works.

Apparently there is a problem with the 2263 Course

- I can understand that a couple of INFO students would have a problem with 2263. They were coddled in the 1181 course by Jon and Leslie, thus preventing them from reaching the level of material that was necessary.
- Then, in 2235 they were again coddled and never truly challenged in 2235.
- Finally, they hit 2263 (second version of the course) and all of a sudden they experience a truly challenging course and instead of meeting the challenge, they ran away. Interestingly I believe had they stuck around longer than 2 weeks they probably would find that the difficulty level was calibrated (which it was), but of course they choose not to, and then they complained. I note, that the individuals to whom them complained did not directly mention this to me, I would have gladly explained my thoughts on the matter and perhaps we could have come to an understanding.

One of the key issues I find in both the CS and INFO students when I encounter them in 2263 is the following:

* Both types of students have a seriously flawed understanding of basic logic (1181 IS NOT ENOUGH) to do any serious programming and to be able to understand more complicated concepts such as exception handling, assertions, and program invariants.


What does a CS 1181 course need

- First off, it needs a level of challenge (not too hard but not too soft), the students need to be pushed to achieve in the course, but not so much that it is impossible.
- This is the first course for both INFO and CS and those are the students served. This is not a required course in any other program, all other students using this as the general education criteria must meet the standard set for those students. The standard is the same regardless of CS or INFO
- The standard:
  - By the end of the course you should have a firm grasp on the use and application of the following techniques in an Object-Oriented programming language
    * Basic operators and their use (+, -, /, %, *, =, ==, !=, &&, ||, <, <=, >, >=, ()) (math, comparison, logic, cast)
    * Variables
    * Execution of a program and the use of expressions and statements
    * Use of functions/methods with and without parameters
    * Logical Flow Control
      - Branching (if and switch)
      - Loops (for and while)
    * Objects and the basics of Object Orientation
      - Construction of objects
      - Attributes and Methods
      - Inheritance
      - Polymorphism
      - Interfaces (the concept not the construct)
      - Abstraction
      - Delegation
      - Overriding and Overloading
    * Packages/Namespaces/Modules and their use
    * Using libraries (i.e., scipy, numpy, pandas, and matplotlib)
    * Documenting and Reading Code
  - A General course outline is as follows:
    Week 1: Introduction and your first program (no lab)
    Week 2: Variables and your first function
    Week 3: Functions, Basic Logic, and Branching
    Week 4: Branching and Comparisons
    Week 5: Lists and Loops
    Week 6: Documentation and Practicum 1 (no lab)
    Week 7: Introduction to Objects
    Week 8: Inheritance
    Week 9: Inheritance
    Week 10: Practicum 2 (no lab)
    Week 11: Libraries 1
    Week 12: Libraries 2
    Week 13: Libraries 3
    Week 14: Libraries 4
    Week 15: Course Wrapup (no lab)
    Finals Week: Practicum 3
- A Basic Teaching Method
  - The intro course should not be taught using slide decks and simple examples
  - The idea is that these students should be comfortable programming and in a programming environment
  - Thus, every single class should be loosely governed by an outline of the topics to be covered
    * Following this outline, the topics are shown through code, which in turn provides an example of how to do this
    * Additionally, students should be provided this example code and encouraged to explore it
    * One day each week an all day laboratory should be made available
      * For 2 hours students can take part, with guidance from an upper class student or graduate student, to conduct a small (but slightly challenging) in-lab which emphasizes the core concepts of the week's lectures
      * For the next week, students are required to complete a small project to further explore solving a problem using the techniques they have learned.
      * These two assignments are grade (the former quite liberally) to provide feedback on how they performed and where they can improve
    * During the semester 3 Practicums (not exams) are given. The idea of the practicum is to evaluate their capability in using programming to solve a problem. The point of 1181 is not to teach them python or C# or any other language, but rather to teach them how to solve problems via programming (i.e., the most basic concept of computer science/informatics)
      * The first two practicums (50 minutes each) have only two problems. These problems are meant to exercise the key concepts covered since the last practicum (or since the first day of class in the case of the first). The problems should be designed to utilize all their knowledge. Yet, any working solution is enough.
      * The last practicum (110 minutes) should have four problmes. These problems are meant to exercise the knowledge learned across the entire course
      * The idea is that the only people to make it through this course are those who have a firm grasp on the use of programming to solve problems. No one gets through becasue they theoretically understand the syntax, or theoretically understand python. They must be capable of demonstrating that they can DO THE WORK. If they demonstrate this on small problems, then we can deem them ready for the next course.


An argument against "going back to what something like 1182"

- INFO students seem by the very nature of the curriculum lacking any real focus. What is it that they study? I have asked those students myself, and the answer is: "I don't really know". The INFO program has had a crisis of identity since I have been here (and possibly quite sometime longer given the name changes it has endured).
- Because of this students coming in have different ideas of what this program is and the types of students it attracts are what I would consider not well prepared for the rigors of creating software.
- It seems that the program wants to achieve the following things:
  - Data Analytics
  - Software Development (I used this term specifically, because it is not software engineering you are teaching)
  - Database Administration
  - IT
- Unfortunately, due to a lack of direction and faculty the program seems to really do none of these well, and all it does is gives students a glimpse into what could be for any one of these careers.
- Additionally, due to the various directions, the students come from a range of capabilities when it comes to programming and their capability to grasp the abstract nature of such an endeavor.
- Thus, the typical (or average) INFO student would not do well in an 1181 as I have laid out above, and tend to do poorly (or drop) in 2235 and 2263, as they currently stand.
- Furthermore, there is one additional student type (which is the CS drop) that for various reasons leaves CS to join INFO.
- I have found that in both CS and INFO there are a number of students whose sights are much higher than their capabilities (Software Development/Engineering is not for everyone) because of these students entering INFO (since they most likely shied away from CS either due to the math requirements or DVB) led to an extremely weak 1181 (when I got here) which was spread across two courses (1181 and 1182).
- This was further compounded by the nature of Jon's teaching (which is to go into way too much detail about individual topics rather than to all students to master the basics and explore these topics in later courses)
- Similar issues pervade the 2220 and 4430 split (why two courses when one will suffice?)

I am proposing, and will join, an Software Engineering Department.

* We would be opening up a degree program that is hyper-focused on Software Engineering and thus, seeks students that will succeed in course related to that topic. Thus, it will not be a good fit for students who want to do IT work (that is what a 2 year program is for), it is also not a good fit for information systems people (as this has become an extremely limiting topic), and this is not a good fit for people wanting to be database administrators. This program, gears students up to be capable of implementing large software systems in a variety of application domains. To be able to work with, but not be, computer scientists (those who focus on algorithms, nuances of languages, and solve truly challenging computational problems). It will also put them on the right path towards one of three primary careers, General Software Engineer and Team Lead, Software Project Manager, or Software Architect, and may eventually lead to positions such as Director of Software Engineering, Chief Architect, or CTO of a software company.

* I noted above that I would be more than happy to join a department which is focused on Software Engineering, but I will not join a department that is spreading itself thin in multiple directions, leading to students with no real skills or mastery of a valuable skill. There is nothing wrong with IT or DBA jobs, but these are no longer the purview of a 4 year program. I would argue the same could be said about Software Development (as this is simply teaching students a language, a framework, and a database so that they can solve problems - 2 year degree anyone?). Software Engineering, is and has been its own discipline (with PhD programs since the 1960's). The idea is to teach similar courses in the first half of the program as does CS (but with a specific focus and thus separate classes).

The Course Progression (based on the concepts and key knowledge areas for an SE degree as describe by the ACM Guideline)

1181 - Introduction to Programming. The first required course and a prerequisite to 1182

1184 - Foundations of Software Engineering. a prerequisite to 2282

* This course is not 1182 as was previously taught. It is an amalgam of concepts from MATH 1187 and CS 2235 but with a focus on the programming aspects and lack use
* This course also serves to transition students from python to Java, via exercises, comparative programming and direct syntax teaching methods
* The first section covers basic and advanced logic (propositional and predicate logics) and basic set theory.
  - Basic Boolean Propositional logic is taught using basic python and java logical operators and syntax
  - Predicate Logic is taught using concepts such as functors and basic boolean returning functions. Additionally, we bring in the basics of functional programming
  - Set theory is taught by introducing the use of sets from the language library (both python sets and java sets are introduced)
    * we then show not only what the basic operations are but why we would want to use them (from a business/domain specific appraoch)
* The next section focuses on recursion and using this as an elegant way to address specific problems
  - show how recursion compares to iteration
  - discuss when recusion is most warranted (problems decomposable into sub-problems)
* Next we work with linear data structures (note i did not say create linear data structures)
  - Since students already know about lists from pyhthon, we need to show lists from java
  - We also note different ways in which lists are constructed (as it applies to peformance and other characteristics) and why we would want to choose different approaches
  - Additionally, this becomes a good place to teach the use of programming to abstractions rather than implementations (dynamic binding)
* Next we return to sets and maps to discuss
  - We introduce maps (why because they make lookup easier and should have already been noted in 1181) we want to show how to use these in Java and python
  - We discuss the use of equals and hashcode in Java and how to practically generate these two functions (not why they work from a CS standpoint)
* Next we start to discuss more advanced data structures (not implementation, and here is where Kevin and Jon jump in (no INFO student needs trees or graphs unless they work with a UI (scene graph or directory tree, or tree component or if they work with a Non SQL db like Graph-based etc. or work with the social graph underlying facebook's api).
  - We discuss a few Java api's (at this point we have completely moved off of python) for dealing with trees and graphs, but the focus is on what these are good for not how to make them
  - We will discuss a few basic traversals and searches (recursion anyone) why, because this is the basis of distributed algorithms, such as Map Reduce, Apache Spark, etc. and for how GitHub manages data, and so on.
* Finally the course ends with a survey of several algorithmic design approaches
  - The students have already seen some simple cases of recursion in use
  - The goal of this section is to discuss common patterns of problems, patterns to solving those problems (i.e., algorithm patterns) and a general approach to identifying a potential solution and applying it in practice.
  - As part of this the students should be exposed to informal Big-O analysis and the asymptotic nature of problems and algorithmic solutions (i.e., why triply nesting loops and exponetial solutions are bad) and why computer science exists.
  - Why software engineers go to computer scientists when confronted with such problems
* The final topic is the use and application of Regular Expressions
  - Students are not expected to have mastered this concept but, rather to be capable of writing simple expressions to extract particular data from strings.
  
2281 - Introduction to Object Oriented Analysis and Design -> Prerequisite for the following courses: 3307, 3308, 3309, 3380

* This is not a replacement for 3307. Rather this is avanced object oriented programming
* What students learn here:
  - The very basics of OO Analysis using Use Cases and the basic nature of Requirements and Conceptual Classes and Domain Analysis
  - The Use of Sequence Diagrams and Class Diagrams to identify Software and Implementation classes, to assign responsibliities to these classes, and identify the attributes of these classes by extracting information from multiple use cases.
  - Describing business rules as part of use cases
  - The basics of Noun-Verb analysis from use cases
  - The basics of the OOADI process (though not formalized -> see 3307)
  - The underlying reasons for project and code documentation
  - The need for having a style for programming
  - Language Features supporting OO
    - Serialization (to both binary and JSON)
    - The Object Class and its methods (clone, equals, toString, etc.)
  - Defensive coding techniques including
    - Exception handling
    - Assertions
    - Input Validation
    - Program by contract
  - Basics of software testing (through practical use)
    - Unit Testing
    - Specification/Acceptance testing (and how to specify these tests as part of use cases)
  - The use of advanced software engineering tools
    - The use of Git and why it matters and how to manage a git repository
    - The basics of automated build and dependency management explored through the use of Java and Gradle
    - Simple static analysis tools for finding bugs/violations in software
    - Simple static analysis tools for evaluating the style of a projects code
    - Tools to extract documentation from code
    - Tools to package and deploy software (installers and docker)
  - Basic ideas of software architecture
    - Client-Server systems
    - Distributed Programming (RPC, REST)
  - Basics of UI Design
    - MVC
    - Wireframing
    - Principles of UI Design
    - Using a basic UI Framework such as JavaFX
  - Initial concepts of databases and data persistence explored though an introduction to SQL and an ORM
  - Initial description of Teamwork and Team projects
    - Basics of team dynamics
    - Interpersonal Contracts
    - Working together
  - Design Patterns and Principles
    * SOLID and other principles
    * GoF Patterns
    * Some basic Architectural Patterns
  - Using state diagrams for the UI
  - Build automation and CI/CD with Travis CI
  - Refactoring
    
3307 - Introduction to Software Engineering -> 443X and all 445X courses

* Processes and Planning/Inception (1 - 2 weeks) with a focus on BUP or AUP
* Requirements Engineering (2 Weeks) with a practicum
  - Gathering
  - Specification
  - Basics
* Design - Using UML, IFML, and OCL - 
  - Basic Design expanded from 2282
  - More focus on architectural patterns and distributed/cloud
* Implementation
  - Translating Designs to Code (and the use of code generation techniques)
  - Testing and V&V explored more in depth
* Evolution and Maintenance discussed
* Software Quality and Measurement
* Software Process Improvement
* Primary Means of evaluation is a significant team project which focuses on
  - Following a process
  - A serious requirements engineering and specification (using Use Cases)
  - A serious design phase focused on Sequence Diagrams, Class Diagrams, and IFML for the UI
  - An implementation of a prototype using the same techniques explored in 2282
  - Testing and V&V reviews with instructor
  - Code Reviews with instructor
  - Measurment of the software project and application of refactoring and quality improvement
* Project must go above and beyond to get an A

3308 - User Interface/User Experience -> 443X

3309 - Database Design -> same as 4407

3380 - Networks

* Explores the basics of networking and the TCP/IP Stack
* Explores networking from the Software Engineering viewpoint
  - construction of client/server systems using both tcp/udp protocols
  - understanding of RFCs
  - using RPC/RMI
  - Basics of programming in the cloud
  - REST based development and using REST APIs (JSON/XML)
  - GraphQL
* Explores the basics of Multithreaded/Multiprocess programming and its use in the development of the server side and client-side systems
* Explores the basics of developing webapps
* Explores concepts related to architecture and operating systems which support networking
* Focuses on using Java and Python in a networking sense.

3384 - Foundations of Software Engineering II

* This course is meant to integrate 2217 and basic data analysis with the curricula
* In this course students will explore empirical software engineering from the standpoint of how empiricism can improve the following
  - Selection of and evaluation of the effectiveness of technologies
  - Selection of and evaluation of the effectiveness of techniques
  - Development of a measurment and improvement approach for software projects, teams and organizations
  - Topics include the following
    * Basics of Empiricism and Theory Building for Software Engineering
    * Basic ideas from empirical methods
    * Measurement Theory and Metrics
    * GQM+Strategies
    * Experimentation
    * Case Studies
    * Surveys
    * Interviews
    * Grounded Theory Approaches
* Though these are what could be called general research methods, the focus of this course is less on "traditional research" and more on the application of research methods to improving software engineering and technique from within an organization, team, or project.

4420 - Programming Paradigms

* It is necessary to prepare students for lifelong learning in the SE field.
* Particularly necessary is that they can handle working with multiple languages, multiple programming approaches, and multiple threads
* This course focuses on these very issues
* Students will learn the following
  - Using a functional language (i.e., ML, Clojure, or Haskell) to program from a functional standpoint. Functional programming has been touted as a potential key towards addressing various issues in scalability. Additionally, the fundamental concepts (map and reduce) from functional programming have become the basis for the very idea of advanced data manipulation techniques in the cloud (mapreduce, bigtable, nosql, and serverless programming)
  - Using a OO language (i.e., Java, C#, Ruby, Python) this is mainly a reprieve for the students, but can serve as a means to explore how memory is used by these languages (extremely useful insight given the lack of concern students seem to have for this)
  - Using a declarative language (prolog, ocl, sql) this is mainly to get students to focus on describing things rather than the standard imperative method of programming.
  - After learning the basics of each of these languages they will experience different challenges, focused on gaining deeper insights in to advanced programming issues.
  - Particularly, they will address concurrent/multithreaded programming in each language. For each language a different concurrency paradigm will be explored to
  - They will also learn to use some basic tools for those languages in order to connect back to the concepts learned throughout the rest of the curricula
  - A deeper investigation of the use of regular expressions in these various languages
* Finally, they will learn the basics of describing grammars and the implementation of a DSL (domain specific language) within each language studied. The goal of this is to explore an alternative (and one that is likely to be seen in their career) to using standard (but extremely general) data description languages such as SQL, JSON, or XML.
* Languages will be explored in 5 week increments

443X - WebApps/MobileApps/CloudApps/IoTApps -> Pre-req to 4488 (must have complete a 443X course) and Pre-co-req: 4451, 4452, 4453

* The 443X courses focus deeply on the implementation of systems on a specific platform type
* This course should be focused on guiding students towards completing a project
  - Provides guidance in current technologies/techniques for these components but does not lock students into any single approach (i.e., Asp.NET for Web or Kotlin for Mobile) but rather discusses multiple approaches upfront and (since it is a 44XX course) expects the students to explore these approaches and make reasoned decisions about the technology for their project.
  - Does not prescribe the project, but expects students to come up with a project within the constraints of the course.
  - Instructors are encouraged to discuss the underlying software engineering issues associated with the particular application area (mobile, iot, web, cloud) (i.e., issues with UI, development standards, connectivity issues, etc.) and any workarounds that may be applicable.
  - Patterns and development strategies are to be discussed, but this is not an advanced 1181 course where we teach programming, instead this is guidance for operating the implementation stage of developing for a particular platform. Focus should be on the transition from design to implementation for the specific application type, testing issues (i.e., emulators for IoT and mobile) and deployment strategies (i.e., working with service providers in Cloud, accessing distribution media such as Android Play Store) and making the system ready for deployment.
  - Students are expected to work in teams and to follow a process: Planning/Inception, Requirements Engineering, Design, Implementation (bulk of the course) and Testing, and Deployment.
  - The project must be deployable by the end of the course to be considered passable
  
4451 - Software Architecture and Requirements -> Pre/Co-Req 4488

4452 - Software Testing and Quality Analysis -> Pre/Co-Req 4488

4453 - Software Evolution, Maintenance, and Analysis -> Pre/Co-Req 4488

4488 - Capstone

The Flow:

1181
  |
1184
  |-------------------------------------+
2281                                    |
  |-------------------+-----+-----+     |
  |                   |     |     |     |
3307                 3308  3309  3380  3384
  |-----+-----+----+  /     |     |     |
  |     |     |    | |------+-----+     |
  +=====+=====+===443X                  |
  |     |     |     |
4451  4452  4453    |                   |
  :     :     :     |                   |
  +-----+-----+-----+-------------------+
  |
4488
