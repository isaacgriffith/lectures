# Learning Outcomes {-}

## The following outcomes will be evaluated via homework assignments and exams {-}

### Software Processes {-}

* Describe how software can interact with and participate in various systems including information management, embedded, process control, and communications systems. [Familiarity]
* Describe the relative advantages and disadvantages among several major process models (e.g., waterfall, iterative, and agile). [Familiarity]
* Describe the different practices that are key components of various process models. [Familiarity]
* Differentiate among the phases of software development. [Familiarity]
* Describe how programming in the large differs from individual efforts with respect to understanding a large code base, code reading, understanding builds, and understanding context of changes. [Familiarity]
* Explain the concept of a software lifecycle and provide an example, illustrating its phases including the deliverables that are produced. [Familiarity]
* Compare several common process models with respect to their value for development of particular classes of software systems taking into account issues such as requirement stability, size, and non-functional characteristics [Usage]
* Define software quality and describe the role of quality assurance activities in the software process. [Familiarity]
* Describe the intent and fundamental similarities among process improvement approaches. [Familiarity]
* Compare several process improvement models such as CMM, CMMI, CQI, Plan-Do-Check-Act, or ISO9000. [Assessment]
* Explain the role of process maturity models in process improvement. [Familiarity]
* Describe several process metrics for assessing and controlling a project. [Familiarity]

### Requirements Engineering {-}

* List the key components of a use case or similar description of some behavior that is required for a system. [Familiarity]
* Describe how the requirements engineering process supports the elicitation and validation of behavioral requirements. [Familiarity]
* Interpret a given requirements model for a simple software system. [Familiarity]
* Describe the fundamental challenges of and common techniques used for requirements elicitation. [Familiarity]
* List the key components of a data model (e.g., class diagrams or ER diagrams). [Familiarity]
* Conduct a review of a set of software requirements to determine the quality of the requirements with respect to the characteristics of good requirements. [Usage]
* Compare the plan-driven and agile approaches to requirements specification and validation and describe the benefits and risks associated with each. [Familiarity]

### Software Design {-}

* Articulate design principles including separation of concerns, information hiding, coupling and cohesion, and encapsulation. [Familiarity]
* Within the context of a single design paradigm, describe one or more design patterns that could be applicable to the design of a simple software system. [Familiarity]
* For the design of a simple software system within the context of a single design paradigm, describe the software architecture of that system. [Familiarity]
* Given a high-level design, identify the software architecture by differentiating among common software architectures such as 3-tier, pipe-and-filter, and client-sever. [Familiarity]
* Describe a form of refactoring and discuss when it may be applicable. [Familiarity]
* Explain how suitable components might need to be adapted for use in the design of a software product [Familiarity]

### Software Project Management {-}

* Discuss common behaviors that contribute to the effective functioning of a team. [Familiarity]
* List several examples of software risks. [Familiarity]
* Describe the impact of risk in a software development lifecycle. [Familiarity]
* Describe different categories of risk in software systems. [Familiarity]
* Describe how the choice of process model affects team organizational structures and decision-making processes. [Familiarity]
* Using a particular software process, describe the aspects of a project that need to be planned and monitored, (e.g., estimates of size and effort, a schedule, resource allocation, configuration control, change management, and project risk identification and management). [Familiarity]
* Describe the impact of risk tolerance on the software development process. [Assessment]
* Identify risks and describe approaches to managing risk (avoidance, acceptance, transference, mitigation), and characterize the strengths and shortcomings of each. [Familiarity]
* Apply the basic principles of risk management in a variety of simple scenarios including a security situation. [Usage]

### Software Verification and Validation {-}

* Distinguish between program validation and verification. [Familiarity]
* Describe the role that tools can play in the validation of software. [Familiarity]
* Describe and distinguish among the different types and levels of testing (unit, integration, systems, and acceptance). [Familiarity]
* Describe techniques for identifying significant test cases for integration, regression and system testing. [Familiarity]
* Describe how to select good regression tests and automate them. [Familiarity]
* Discuss the limitations of testing in a particular domain. [Familiarity]

### Software Evolution {-}

* Identify the principal issues associated with software evolution and explain their impact on the software lifecycle. [Familiarity]
* Discuss the challenges of evolving systems in a changing environment. [Familiarity]
* Outline the process of regression testing and its role in release management. [Familiarity]
* Discuss the advantages and disadvantages of different types of software reuse. [Familiarity]

### Software Reliability {-}

* Explain the problems that exist in achieving very high levels of reliability. [Familiarity]
* Describe how software reliability contributes to system reliability. [Familiarity]
* List approaches to minimizing faults that can be applied at each stage of the software lifecycle. [Familiarity]

### Information Management Concepts {-}

* Describe how humans gain access to information and data to support their needs. [Familiarity]
* Describe the advantages and disadvantages of central organizational control over data. [Assessment]
* Identify the careers/roles associated with information management (e.g., database administrator, data modeler, application developer, end-user). [Familiarity]
* Compare and contrast information with data and knowledge. [Assessment]
* Identify issues of data persistence for an organization. [Familiarity]

### Principles of Secure Design {-}

* Describe the principle of least privilege and isolation as applied to system design. [Familiarity]
* Summarize the principle of fail-safe and deny-by-default. [Familiarity]
* Discuss the implications of relying on open design or the secrecy of design for security. [Familiarity
* Explain the goals of end-to-end data security. [Familiarity]
* Discuss the benefits of having multiple layers of defenses. [Familiarity]
* For each stage in the lifecycle of a product, describe what security considerations should be evaluated. [Familiarity]
* Describe the cost and trade-offs associated with designing security into a product. [Familiarity]

### HCI Foundations {-}

* Discuss why human-centered software development is important. [Familiarity]
* Summarize the basic precepts of psychological and social interaction. [Familiarity]
* Create and conduct a simple usability test for an existing software application. [Assessment]

### HCI Designing Interaction {-}

* Discuss at least one national or international user interface design standard. [Familiarity]

## The following outcomes will be evaluated via the project {-}

### Software Processes {-}

* Assess a development effort and recommend potential changes by participating in process improvement (using a model such as PSP) or engaging in a project retrospective. [Usage]
* Use project metrics to describe the current state of a project. [Usage].

### Requirements Engineering {-}

* Identify both functional and non-functional requirements in a given requirements specification for a software system. [Usage]
* Apply key elements and common methods for elicitation and analysis to produce a set of software requirements for a medium-sized software system [Usage].
* Use a common, non-formal method to model and specify the requirements for a medium-size software system. [Usage]
* Create a prototype of a software system to mitigate risk in requirements. [Usage]

### Software Design {-}

* Use a design paradigm to design a simple software system, and explain how system design principles have been applied in this design. [Usage]
* Construct models of the design of a simple software system that are appropriate for the paradigm used to design it. [Usage]
* For a simple system suitable for a given scenario, discuss and select an appropriate design paradigm. [Usage]
* Create appropriate models for the structure and behavior of software products from their requirements specifications. [Usage]
* Explain the relationships between the requirements for a software product and its design, using appropriate models. [Assessment]
* Investigate the impact of software architectures selection on the design of a simple system. [Assessment]
* Select suitable components for use in the design of a software product. [Usage]
* Design a contract for a typical small software component for use in a given system. [Usage]

### Software Project Management {-}

* Create and follow an agenda for a team meeting. [Usage]
* Identify and justify necessary roles in a software development team. [Usage]
* Understand the sources, hazards, and potential benefits of team conflict. [Usage]
* Apply a conflict resolution strategy in a team setting. [Usage]
* Use an *ad hoc* method to estimate software development effort (e.g., time) and compare to actual effort required. [Usage]
* Demonstrate through involvement in a team project the central elements of team building and team management. [Usage]
* Create a team by identifying appropriate roles and assigning roles to team members. [Usage]
* Assess and provide feedback to teams and individuals on their performance in a team setting. [Usage]
* Track the progress of some stage in a project using appropriate project metrics. [Usage]
* Compare simple software size and cost estimation techniques. [Usage]
* Use a project management tool to assist in the assignment and tracking of tasks in a software development project. [Usage]
* Explain how risk affects decisions in the software development  process. [Usage]
* Identify security risks for a software system. [Usage]
* Demonstrate a systematic approach to the task of identifying hazards and risks in a particular situation. [Usage]
* Conduct a cost/benefit analysis for a risk mitigation approach. [Usage]
* Identify and analyze some of the risks for an entire system that arise from aspects other than the software. [Usage]

### Software Verification and Validation {-}

* Undertake, as part of a team activity, an inspection of a medium-size code segment. [Usage]
* Create and document a set of tests for a medium-size code segment. [Usage]
* Use a defect tracking tool to manage software defects in a small software project. [Usage]

### Software Evolution {-}

* Estimate the impact of a change request to an existing product of medium size. [Usage]
* Use refactoring in the process of modifying a software component. [Usage]

### HCI Foundations {-}

* Develop and use a conceptual vocabulary for analyzing human interaction with software: affordance, conceptual model, feedback, and so forth. [Usage]
* Define a user-centered design process that explicitly takes account of the fact that the user is not like the developer of their acquaintances. [Usage]

### HCI Designing Interaction {-}

* For an identified user group, undertake and document an analysis of their needs. [Assessment]
* Create a simple application, together with help and documentation, that supports a graphical user interface. [Usage]
* Conduct a quantitative evaluation and discuss/report the results. [Usage]
