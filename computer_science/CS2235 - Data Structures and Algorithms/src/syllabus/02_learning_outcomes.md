# Learning Outcomes {-}

## Object-Oriented Programming {-}

- Define and use iterators and other operations on aggregates, including operations that take functions as arguments, in multiple programming languages, selecting the most natural idioms for each language. [U]

## Basic Type System {-}

- Give an example program that does not type-check in a particular language and yet would have no error if run. [F]
- Discuss the differences among generics, subtyping, and overloading. [F]
- Explain multiple benefits and limitations of static typing in writing, maintaining, and debugging software. [F]
- For multiple programming languages, identify program properties checked statically and program properties checked dynamically. [U]
- Use types and type-error messages to write and debug programs. [U]
- Define and use program pieces (such as functions, classes, methods) that use generic types, including for collections. [U]

## Basic Analysis {-}

- Explain what is meant by “best”, “expected”, and “worst” case behavior of an algorithm. [F]
- In the context of specific algorithms, identify the characteristics of data and/or other conditions or assumptions that lead to different behaviors. [A]
- State the formal definition of big O. [F]
- List and contrast standard complexity classes. [F]
- Give examples that illustrate time-space trade-offs of algorithms. [F]
- Determine informally the time and space complexity of simple algorithms. [U]
- Perform empirical studies to validate hypotheses about runtime stemming from mathematical analysis. Run algorithms on input of various sizes and compare performance. [A]

## Fundamental Data Structures {-}

- Describe common applications for each of the following data structures: stack, queue, priority queue, set, and map. [F]
- Compare and contrast the costs and benefits of dynamic and static data structure implementations. [A]
- Write programs that use each of the following data structures: arrays, records/structs, strings, linked lists, stacks, queues, sets, and maps. [U]
- Compare alternative implementations of data structures with respect to performance. [A]

## Fundamental Data Structures and Algorithms {-}

- Implement simple search algorithms and explain the differences in their time complexities. [A]
- Be able to implement common quadratic and O(N log N) sorting algorithms. [U]
- Solve problems using fundamental graph algorithms, including depth-first and breadth-first search. [U]
- Solve problems using graph algorithms, including single-source and all-pairs shortest paths, and at least one minimum spanning tree algorithm. [U]
- Trace and/or implement a string-matching algorithm. [U]
- Describe the implementation of hash tables, including collision avoidance and resolution. [F]
- Discuss the runtime and memory efficiency of principal algorithms for sorting, searching, and hashing. [F]
- Discuss factors other than computational efficiency that influence the choice of algorithms, such as programming time, maintainability, and the use of application-specific patterns in the input data. [F]
- Explain how tree balance affects the efficiency of various binary search tree operations. [F]
- Describe the heap property and the use of heaps as an implementation of priority queues. [F]

## Algorithms and Design {-}

- Implement a divide-and-conquer algorithm for solving a problem. [U]
- Apply the techniques of decomposition to break a program into smaller pieces. [U]
- Identify the data components and behaviors of multiple abstract data types. [U]
- Implement a coherent abstract data type, with loose coupling between components and behaviors. [U]
- Determine whether a recursive or iterative solution is most appropriate for a problem. [A]

## Introduction Modeling and Simulation {-}

- Create a simple, formal mathematical model of a real-world situation and use that model in a simulation. [U]
- Create a simple display of the results of a simulation. [U]
- Explain the concept of modeling and the use of abstraction that allows the use of a machine to solve a problem. [F]
