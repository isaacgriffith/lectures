# CS 2263

## Software Requirements

1. Software Requirements Fundamentals

1.1. Definition of a Software Requirement
1.2. Product and Process Requirements
1.3. Functional and Nonfunctional Requirements
1.4. Emergent Properties
1.5. Quantifiable Requirements
1.6. System Requirements and Software Requirements

6. Requirements Validation

6.4. Acceptance Tests

## Software Design

1. Software Design Fundamentals

1.1. General Design Concepts
1.2. Context of Software Design
1.3. Software Design Process
1.4. Software Design Principles

3. Software Structure and Architecture

3.3. Design Patterns

## Software Configuration Management

6. Software Release Management and Delivery

6.1. Software Building
6.2. Software Release Management

# CS 3321

## Software Requirements

2. Requirements Process

2.1. Process Models
2.2. Process Actors
2.3. Process Support and Management
2.4. Process Quality and Improvement

3. Requirements Elicitation

3.1. Requirements Sources
3.2. Elicitation Techniques

4. Requirements Analysis

4.1. Requirements Classification
4.2. Conceptual Modeling

6. Requirements Validation

6.1. Requirements Reviews
6.2. Prototyping

7. Practical Considerations

7.1. Iterative Nature of the Requirements Process

## Software Design

2. Key Issues in Software Design

2.1. Concurrency
2.2. Control and Handling of Events
2.3. Data Persistence
2.4. Distribution of Components
2.5. Error and Exception Handling and Fault Tolerance
2.6. Interaction and Presentation
2.7. Security

3. Software Structure and Architecture

3.1. Architectural Structures and Viewpoints
3.2. Architectural Styles
3.3. Design Patterns

5. Software Design Quality Analysis and Evaluation

5.1. Quality Attributes
5.2. Quality Analysis and Evaluation Techniques
5.3. Measures

6. Software Design Notations

6.1. Structural Descriptions (Static View)
6.2. Behavioral Descriptions (Dynamic View)

7. Software Design Strategies and Methods

7.1. General Strategies
7.2. Function-Oriented (Structured) Design
7.3. Object-Oriented Design
7.4. Data Structure-Centered Design
7.5. Component-Based Design (CBD)
7.6. Other Methods

8. Software Design Tools

## Software Configuration Management
1. Management of the SCM Process

1.1. Organizational Context for SCM
1.2. Constraints and Guidance for the SCM Process
1.3. Planning for SCM
1.4. SCM Plan
1.5. Surveillance of Software Configuration Management

2. Software Configuration Identification

2.1. Identifying Items to Be Controlled
2.2. Software Library

3. Software Configuration Control

3.1. Requesting, Evaluating, and Approving Software Changes
3.2. Implementing Software Changes
3.3. Deviations and Waivers

4. Software Configuration Status Accounting

4.1. Software Configuration Status Information
4.2. Software Configuration Status Reporting

5. Software Configuration Auditing

5.1. Software Functional Configuration Audit
5.2. Software Physical Configuration Audit
5.3. In-Process Audits of a Software Baseline

7. Software Configuration Management Tools

## Software Engineering Management
1. Initiation and Scope Definition

1.1. Determination and Negotiation of Requirements
1.2. Feasibility Analysis
1.3. Process for the Review and Revision of Requirements

2. Software Project Planning

2.1. Process Planning
2.2. Determine Deliverables
2.3. Effort, Schedule, and Cost Estimation
2.4. Resource Allocation
2.5. Risk Management
2.6. Quality Management
2.7. Plan Management

3. Software Project Enactment

3.1. Implementation of Plans
3.2. Software Acquisition and Supplier Contract Management
3.3. Implementation of Measurement Process
3.4. Monitor Process
3.5. Control Process
3.6. Reporting

4. Review and Evaluation

4.1. Determining Satisfaction of Requirements
4.2. Reviewing and Evaluating Performance

5. Closure

5.1. Determining Closure
5.2. Closure Activities

6. Software Engineering Measurement

6.1. Establish and Sustain Measurement Commitment
6.2. Plan the Measurement Process
6.3. Perform the Measurement Process
6.4. Evaluate Measurement

7. Software Engineering Management Tools

## Software Engineering Process
1. Software Process Definition

1.1. Software Process Management
1.2. Software Process Infrastructure

2. Software Life Cycles

2.1. Categories of Software Processes
2.2. Software Life Cycle Models
2.3. Software Process Adaptation
2.4. Practical Considerations

3. Software Process Assessment and Improvement

3.1. Software Process Assessment Models
3.2. Software Process Assessment Methods
3.3. Software Process Improvement Models
3.4. Continuous and Staged Software Process Ratings

4. Software Measurement

4.1. Software Process and Product Measurement
4.2. Quality of Measurement Results
4.3. Software Information Models
4.4. Software Process Measurement Techniques

5. Software Engineering Process Tools

## Software Engineering Models and Methods
1. Modeling

1.1. Modeling Principles
1.2. Properties and Expression of Models
1.3. Syntax, Semantics, and Pragmatics

2. Types of Models

2.1. Information Modeling
2.2. Behavioral Modeling
2.3. Structure Modeling

3. Analysis of Models

3.1. Analyzing for Completeness
3.2. Analyzing for Consistency
3.3. Analyzing for Correctness
3.4. Traceability
3.5. Interaction Analysis

4. Software Engineering Methods

4.1. Heuristic Methods
4.3. Prototyping Methods
4.4. Agile Methods

## Software Quality
1. Software Quality Fundamentals

1.1. Software Engineering Culture and Ethics
1.2. Value and Costs of Quality
1.3. Models and Quality Characteristics
1.4. Software Quality Improvement
1.5. Software Safety

2. Software Quality Management Processes

2.1. Software Quality Assurance
2.2. Verification & Validation
2.3. Reviews and Audits

3. Practical Considerations

3.3. Software Quality Management Techniques
3.4. Software Quality Measurement

4. Software Quality Tools

## Software Engineering Professional Practice
1. Professionalism

1.1. Accreditation, Certification, and Licensing
1.2. Codes of Ethics and Professional Conduct
1.3. Nature and Role of Professional Societies
1.4. Nature and Role of Software Engineering Standards
1.5. Economic Impact of Software
1.6. Employment Contracts
1.7. Legal Issues
1.8. Documentation
1.9. Tradeoff Analysis

2. Group Dynamics and Psychology

2.1. Dynamics of Working in Teams/Groups
2.2. Individual Cognition
2.3. Dealing with Problem Complexity
2.4. Interacting with Stakeholders
2.5. Dealing with Uncertainty and Ambiguity
2.6. Dealing with Multicultural Environments

3. Communication Skills

3.1. Reading, Understanding, and Summarizing
3.2. Writing
3.3. Team and Group Communication
3.4. Presentation Skills

## Software Engineering Economics
1. Software Engineering Economics Fundamentals

1.1. Finance
1.2. Accounting
1.3. Controlling
1.4. Cash Flow
1.5. Decision-Making Process
1.6. Valuation
1.7. Inflation
1.8. Depreciation
1.9. Taxation
1.10. Time-Value of Money
1.11. Efficiency
1.12. Effectiveness
1.13. Productivity

2. Life Cycle Economics

2.1. Product
2.2. Project
2.3. Program
2.4. Portfolio
2.5. Product Life Cycle
2.6. Project Life Cycle
2.7. Proposals
2.8. Investment Decisions
2.9. Planning Horizon
2.10. Price and Pricing
2.11. Cost and Costing
2.12. Performance Measurement
2.13. Earned Value Management
2.14. Termination Decisions
2.15. Replacement and Retirement Decisions

3. Risk and Uncertainty

3.1. Goals, Estimates, and Plans
3.2. Estimation Techniques
3.3. Addressing Uncertainty
3.4. Prioritization
3.5. Decisions under Risk
3.6. Decisions under Uncertainty

4. Economic Analysis Methods

4.1. For-Profit Decision Analysis
4.2. Minimum Acceptable Rate of Return
4.3. Return on Investment
4.4. Return on Capital Employed
4.5. Cost-Benefit Analysis
4.6. Cost-Effectiveness Analysis
4.7. Break-Even Analysis
4.8. Business Case
4.9. Multiple Attribute Evaluation
4.10. Optimization Analysis

5. Practical Considerations

5.1. The “Good Enough” Principle
5.2. Friction-Free Economy
5.3. Ecosystems
5.4. Offshoring and Outsourcing

# CS 4421

## Software Requirements

4. Requirements Analysis

4.1. Requirements Classification
4.2. Conceptual Modeling
4.3. Architectural Design and Requirements Allocation
4.4. Requirements Negotiation
4.5. Formal Analysis

5. Requirements Specification

5.1. System Definition Document
5.2. System Requirements Specification
5.3. Software Requirements Specification

6. Requirements Validation

6.1. Requirements Reviews
6.2. Prototyping
6.3. Model Validation
6.4. Acceptance Tests

7. Practical Considerations

7.1. Iterative Nature of the Requirements Process
7.2. Change Management
7.3. Requirements Attributes
7.4. Requirements Tracing
7.5. Measuring Requirements

8. Software Requirements Tools

## Software Design

3. Software Structure and Architecture

3.1. Architectural Structures and Viewpoints
3.2. Architectural Styles
3.3. Design Patterns
3.4. Architecture Design Decisions
3.5. Families of Programs and Frameworks

## Software Quality

3. Practical Considerations

3.1. Software Quality Requirements

# CS 4422

## Requirements

4. Requirements Analysis

4.5. Formal Analysis

6. Requirements Validation

6.2. Prototyping
6.3. Model Validation
6.4. Acceptance Tests

## Software Testing
1. Software Testing Fundamentals

1.1. Testing-Related Terminology
1.2. Key Issues
1.3. Relationship of Testing to Other Activities

2. Test Levels

2.1. The Target of the Test
2.2. Objectives of Testing

3. Test Techniques

3.1. Based on the Software Engineer’s Intuition and Experience
3.2. Input Domain-Based Techniques
3.3. Code-Based Techniques
3.4. Fault-Based Techniques
3.5. Usage-Based Techniques
3.6. Model-Based Testing Techniques
3.7. Techniques Based on the Nature of the Application
3.8. Selecting and Combining Techniques

4. Test-Related Measures

4.1. Evaluation of the Program Under Test
4.2. Evaluation of the Tests Performed

5. Test Process

5.1. Practical Considerations
5.2. Test Activities

6. Software Testing Tools

6.1. Testing Tool Support
6.2. Categories of Tools

## Software Quality

3. Practical Considerations

3.2. Defect Characterization

## Software Engineering Models and Methods

1. Modeling

1.4. Preconditions, Postconditions, and Invariants

4. Software Engineering Methods

4.2. Formal Methods

# CS 4423

## Software Maintenance
1. Software Maintenance Fundamentals

1.1. Definitions and Terminology
1.2. Nature of Maintenance
1.3. Need for Maintenance
1.4. Majority of Maintenance Costs
1.5. Evolution of Software
1.6. Categories of Maintenance

2. Key Issues in Software Maintenance

2.1. Technical Issues
2.2. Management Issues
2.3. Maintenance Cost Estimation
2.4. Software Maintenance Measurement

3. Maintenance Process

3.1. Maintenance Processes
3.2. Maintenance Activities

4. Techniques for Maintenance

4.1. Program Comprehension
4.2. Reengineering
4.3. Reverse Engineering
4.4. Migration
4.5. Retirement

5. Software Maintenance Tools

# CS 4442

## Software Design

4. User Interface Design

4.1. General User Interface Design Principles
4.2. User Interface Design Issues
4.3. The Design of User Interaction Modalities
4.4. The Design of Information Presentation
4.5. User Interface Design Process
4.6. Localization and Internationalization
4.7. Metaphors and Conceptual Models

2. Key Issues in Software Design

2.6. Interaction and Presentation

Chapter 2: Software Design

2. Key Issues in Software Design

2.1. Concurrency
2.2. Control and Handling of Events
2.3. Data Persistence
2.4. Distribution of Components
2.5. Error and Exception Handling and Fault Tolerance
2.6. Interaction and Presentation
2.7. Security

5. Software Design Quality Analysis and Evaluation

5.1. Quality Attributes
5.2. Quality Analysis and Evaluation Techniques
5.3. Measures

6. Software Design Notations

6.1. Structural Descriptions (Static View)
6.2. Behavioral Descriptions (Dynamic View)

7. Software Design Strategies and Methods

7.1. General Strategies
7.2. Function-Oriented (Structured) Design
7.3. Object-Oriented Design
7.4. Data Structure-Centered Design
7.5. Component-Based Design (CBD)
7.6. Other Methods

8. Software Design Tools
